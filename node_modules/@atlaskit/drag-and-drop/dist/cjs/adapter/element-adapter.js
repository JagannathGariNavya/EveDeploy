"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.draggable = draggable;
exports.monitorForElements = exports.dropTargetForElements = void 0;
var _bindEventListener = require("bind-event-listener");
var _makeAdapter = require("../make-adapter/make-adapter");
var _addAttribute = require("../util/add-attribute");
var _combine = require("../util/combine");
var _getInput = require("../util/get-input");
var draggableRegistry = new WeakMap();
function addToRegistry(args) {
  draggableRegistry.set(args.element, args);
  return function cleanup() {
    draggableRegistry.delete(args.element);
  };
}
var adapter = (0, _makeAdapter.makeAdapter)({
  typeKey: 'element',
  defaultDropEffect: 'move',
  mount: function mount(api) {
    return (0, _bindEventListener.bind)(window, {
      type: 'dragstart',
      listener: function listener(event) {
        var _entry$dragHandle, _entry$dragHandle2, _entry$getInitialData, _entry$getInitialData2;
        if (!api.canStart(event)) {
          return;
        }
        // the closest parent that is a draggable element will be marked as
        // the `event.target` for the event
        var target = event.target;

        // this source is only for elements
        // Note: only HTMLElements can have the "draggable" attribute
        if (!(target instanceof HTMLElement)) {
          return null;
        }

        // see if the thing being dragged is owned by us
        var entry = draggableRegistry.get(target);

        // no matching element found
        // â†’ dragging an element with `draggable="true"` that is not controlled by us
        if (!entry) {
          return null;
        }
        var input = (0, _getInput.getInput)(event);
        var feedback = {
          element: entry.element,
          dragHandle: (_entry$dragHandle = entry.dragHandle) !== null && _entry$dragHandle !== void 0 ? _entry$dragHandle : null,
          input: input
        };

        // Check: does the draggable want to allow dragging?
        if (entry.canDrag && !entry.canDrag(feedback)) {
          // cancel drag operation if we cannot drag
          event.preventDefault();
          return null;
        }

        // Check: is there a drag handle and is the user using it?
        if (entry.dragHandle) {
          var over = document.elementFromPoint(input.clientX, input.clientY);

          // if we are not dragging from the drag handle (or something inside the drag handle)
          // then we will cancel the active drag
          if (!entry.dragHandle.contains(over)) {
            event.preventDefault();
            return null;
          }
        }

        // Must set any media type for iOS15 to work
        // Doing this will fail in firefox though, so we
        // wrap the operation in a try/catch
        try {
          var _event$dataTransfer;
          (_event$dataTransfer = event.dataTransfer) === null || _event$dataTransfer === void 0 ? void 0 : _event$dataTransfer.setData('application/vnd.pdnd', '');
        } catch (e) {}
        var payload = {
          element: entry.element,
          dragHandle: (_entry$dragHandle2 = entry.dragHandle) !== null && _entry$dragHandle2 !== void 0 ? _entry$dragHandle2 : null,
          data: (_entry$getInitialData = (_entry$getInitialData2 = entry.getInitialData) === null || _entry$getInitialData2 === void 0 ? void 0 : _entry$getInitialData2.call(entry, feedback)) !== null && _entry$getInitialData !== void 0 ? _entry$getInitialData : {}
        };
        var makeDragType = {
          key: 'element',
          startedFrom: 'internal',
          payload: payload
        };
        api.start({
          event: event,
          dragInterface: makeDragType
        });
      }
    });
  },
  dispatchEventToSource: function dispatchEventToSource(_ref) {
    var _draggableRegistry$ge, _draggableRegistry$ge2;
    var eventName = _ref.eventName,
      payload = _ref.payload;
    // During a drag operation, a draggable can be:
    // - remounted with different functions
    // - removed completely
    // So we need to get the latest entry from the registry in order
    // to call the latest event functions

    (_draggableRegistry$ge = draggableRegistry.get(payload.source.element)) === null || _draggableRegistry$ge === void 0 ? void 0 : (_draggableRegistry$ge2 = _draggableRegistry$ge[eventName]) === null || _draggableRegistry$ge2 === void 0 ? void 0 : _draggableRegistry$ge2.call(_draggableRegistry$ge,
    // I cannot seem to get the types right here.
    // TS doesn't seem to like that one event can need `nativeSetDragImage`
    // @ts-expect-error
    payload);
  }
});
var dropTargetForElements = adapter.dropTarget;
exports.dropTargetForElements = dropTargetForElements;
var monitorForElements = adapter.monitor;
exports.monitorForElements = monitorForElements;
function draggable(args) {
  // Guardrail: warn if the drag handle is not contained in draggable element
  if (process.env.NODE_ENV !== 'production') {
    if (args.dragHandle && !args.element.contains(args.dragHandle)) {
      // eslint-disable-next-line no-console
      console.warn('Drag handle element must be contained in draggable element', {
        element: args.element,
        dragHandle: args.dragHandle
      });
    }
  }
  // Guardrail: warn if the draggable element is already registered
  if (process.env.NODE_ENV !== 'production') {
    var existing = draggableRegistry.get(args.element);
    if (existing) {
      // eslint-disable-next-line no-console
      console.warn('You have already registered a `draggable` on the same element', {
        existing: existing,
        proposed: args
      });
    }
  }
  return (0, _combine.combine)(
  // making the draggable register the adapter rather than drop targets
  // this is because you *must* have a draggable element to start a drag
  // but you _might_ not have any drop targets immediately
  // (You might create drop targets async)
  adapter.registerUsage(), addToRegistry(args), (0, _addAttribute.addAttribute)(args.element, {
    attribute: 'draggable',
    value: 'true'
  }));
}