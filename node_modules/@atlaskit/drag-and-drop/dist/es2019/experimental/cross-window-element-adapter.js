import { bindAll } from 'bind-event-listener';
import { makeAdapter } from '../make-adapter/make-adapter';
import { combine } from '../util/combine';
import { isEnteringWindow } from '../util/entering-and-leaving-the-window';
const storage = (() => {
  const dataKey = 'private-pdnd-data';
  const resultKey = 'private-pdnd-result';
  function tryParse(raw) {
    if (raw == null) {
      return null;
    }
    try {
      return JSON.parse(raw);
    } catch (e) {
      // failed to parse
      return null;
    }
  }
  function setData(data) {
    // clearing a result when we set data
    clearStorage();
    localStorage.setItem(dataKey, JSON.stringify(data));
  }
  function findData() {
    return tryParse(localStorage.getItem(dataKey));
  }
  function setResult(result) {
    localStorage.setItem(resultKey, result);
  }
  function findResult() {
    const raw = localStorage.getItem(resultKey);
    if (raw == null) {
      return null;
    }

    // TODO: improve type
    return raw;
  }
  function clearStorage() {
    localStorage.removeItem(dataKey);
    localStorage.removeItem(resultKey);
  }
  return {
    clearStorage,
    setData,
    findData,
    setResult,
    findResult
  };
})();
const adapter = makeAdapter({
  typeKey: 'experimental-cross-window-element',
  defaultDropEffect: 'move',
  mount(api) {
    return combine(bindAll(window, [{
      type: 'dragenter',
      listener(event) {
        if (!api.canStart(event)) {
          return;
        }

        // already cancelled by something else
        if (event.defaultPrevented) {
          return;
        }
        if (!isEnteringWindow({
          dragEnter: event
        })) {
          return;
        }

        // we only care about when the window is being first entered
        if (event.relatedTarget != null) {
          return null;
        }
        const data = storage.findData();
        if (data == null) {
          return;
        }
        const dragInterface = {
          key: 'experimental-cross-window-element',
          startedFrom: 'external',
          payload: {
            data
          }
        };
        api.start({
          event,
          dragInterface
        });
      }
    },
    // always clear a external drag result from another window before a drag starts
    {
      type: 'dragstart',
      listener: storage.clearStorage,
      options: {
        capture: true
      }
    }]), adapter.monitor({
      onDrop(payload) {
        const result = payload.location.current.dropTargets.length > 0 ? 'moved' : 'none';
        storage.setResult(result);
      }
    }));
  }
});
export function setCrossWindowData({
  data
}) {
  storage.setData(data);
}
export function extractCrossWindowResult() {
  return storage.findResult();
}
export const dropTargetForCrossWindowElements = args => {
  return combine(
  // at least one drop target required before we will start listening for cross element dragging
  adapter.registerUsage(), adapter.dropTarget(args));
};
export const monitorForCrossWindowElements = adapter.monitor;