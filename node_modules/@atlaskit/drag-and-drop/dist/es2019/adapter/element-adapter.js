import { bind } from 'bind-event-listener';
import { makeAdapter } from '../make-adapter/make-adapter';
import { addAttribute } from '../util/add-attribute';
import { combine } from '../util/combine';
import { getInput } from '../util/get-input';
const draggableRegistry = new WeakMap();
function addToRegistry(args) {
  draggableRegistry.set(args.element, args);
  return function cleanup() {
    draggableRegistry.delete(args.element);
  };
}
const adapter = makeAdapter({
  typeKey: 'element',
  defaultDropEffect: 'move',
  mount(api) {
    return bind(window, {
      type: 'dragstart',
      listener(event) {
        var _entry$dragHandle, _entry$dragHandle2, _entry$getInitialData, _entry$getInitialData2;
        if (!api.canStart(event)) {
          return;
        }
        // the closest parent that is a draggable element will be marked as
        // the `event.target` for the event
        const target = event.target;

        // this source is only for elements
        // Note: only HTMLElements can have the "draggable" attribute
        if (!(target instanceof HTMLElement)) {
          return null;
        }

        // see if the thing being dragged is owned by us
        const entry = draggableRegistry.get(target);

        // no matching element found
        // â†’ dragging an element with `draggable="true"` that is not controlled by us
        if (!entry) {
          return null;
        }
        const input = getInput(event);
        const feedback = {
          element: entry.element,
          dragHandle: (_entry$dragHandle = entry.dragHandle) !== null && _entry$dragHandle !== void 0 ? _entry$dragHandle : null,
          input
        };

        // Check: does the draggable want to allow dragging?
        if (entry.canDrag && !entry.canDrag(feedback)) {
          // cancel drag operation if we cannot drag
          event.preventDefault();
          return null;
        }

        // Check: is there a drag handle and is the user using it?
        if (entry.dragHandle) {
          const over = document.elementFromPoint(input.clientX, input.clientY);

          // if we are not dragging from the drag handle (or something inside the drag handle)
          // then we will cancel the active drag
          if (!entry.dragHandle.contains(over)) {
            event.preventDefault();
            return null;
          }
        }

        // Must set any media type for iOS15 to work
        // Doing this will fail in firefox though, so we
        // wrap the operation in a try/catch
        try {
          var _event$dataTransfer;
          (_event$dataTransfer = event.dataTransfer) === null || _event$dataTransfer === void 0 ? void 0 : _event$dataTransfer.setData('application/vnd.pdnd', '');
        } catch (e) {}
        const payload = {
          element: entry.element,
          dragHandle: (_entry$dragHandle2 = entry.dragHandle) !== null && _entry$dragHandle2 !== void 0 ? _entry$dragHandle2 : null,
          data: (_entry$getInitialData = (_entry$getInitialData2 = entry.getInitialData) === null || _entry$getInitialData2 === void 0 ? void 0 : _entry$getInitialData2.call(entry, feedback)) !== null && _entry$getInitialData !== void 0 ? _entry$getInitialData : {}
        };
        const makeDragType = {
          key: 'element',
          startedFrom: 'internal',
          payload
        };
        api.start({
          event,
          dragInterface: makeDragType
        });
      }
    });
  },
  dispatchEventToSource: ({
    eventName,
    payload
  }) => {
    var _draggableRegistry$ge, _draggableRegistry$ge2;
    // During a drag operation, a draggable can be:
    // - remounted with different functions
    // - removed completely
    // So we need to get the latest entry from the registry in order
    // to call the latest event functions

    (_draggableRegistry$ge = draggableRegistry.get(payload.source.element)) === null || _draggableRegistry$ge === void 0 ? void 0 : (_draggableRegistry$ge2 = _draggableRegistry$ge[eventName]) === null || _draggableRegistry$ge2 === void 0 ? void 0 : _draggableRegistry$ge2.call(_draggableRegistry$ge,
    // I cannot seem to get the types right here.
    // TS doesn't seem to like that one event can need `nativeSetDragImage`
    // @ts-expect-error
    payload);
  }
});
export const dropTargetForElements = adapter.dropTarget;
export const monitorForElements = adapter.monitor;
export function draggable(args) {
  // Guardrail: warn if the drag handle is not contained in draggable element
  if (process.env.NODE_ENV !== 'production') {
    if (args.dragHandle && !args.element.contains(args.dragHandle)) {
      // eslint-disable-next-line no-console
      console.warn('Drag handle element must be contained in draggable element', {
        element: args.element,
        dragHandle: args.dragHandle
      });
    }
  }
  // Guardrail: warn if the draggable element is already registered
  if (process.env.NODE_ENV !== 'production') {
    const existing = draggableRegistry.get(args.element);
    if (existing) {
      // eslint-disable-next-line no-console
      console.warn('You have already registered a `draggable` on the same element', {
        existing,
        proposed: args
      });
    }
  }
  return combine(
  // making the draggable register the adapter rather than drop targets
  // this is because you *must* have a draggable element to start a drag
  // but you _might_ not have any drop targets immediately
  // (You might create drop targets async)
  adapter.registerUsage(), addToRegistry(args), addAttribute(args.element, {
    attribute: 'draggable',
    value: 'true'
  }));
}