import { addAttribute } from '../util/add-attribute';
import { combine } from '../util/combine';
function copyReverse(array) {
  return array.slice(0).reverse();
}
export function makeDropTarget({
  typeKey,
  defaultDropEffect
}) {
  const registry = new WeakMap();
  const dropTargetDataAtt = `data-drop-target-for-${typeKey}`;
  const dropTargetSelector = `[${dropTargetDataAtt}]`;
  function addToRegistry(args) {
    registry.set(args.element, args);
    return () => registry.delete(args.element);
  }
  function dropTargetForConsumers(args) {
    // Guardrail: warn if the draggable element is already registered
    if (process.env.NODE_ENV !== 'production') {
      const existing = registry.get(args.element);
      if (existing) {
        // eslint-disable-next-line no-console
        console.warn('You have already registered a `droppable` on the same element', {
          existing,
          proposed: args
        });
      }
    }
    return combine(addAttribute(args.element, {
      attribute: dropTargetDataAtt,
      value: 'true'
    }), addToRegistry(args));
  }
  function getActualDropTargets({
    source,
    target,
    input,
    result = []
  }) {
    var _args$getData, _args$getData2, _args$getDropEffect, _args$getDropEffect2, _args$getIsSticky;
    if (!(target instanceof Element)) {
      return result;
    }
    const closest = target.closest(dropTargetSelector);

    // Cannot find anything else
    if (closest == null) {
      return result;
    }
    const args = registry.get(closest);

    // error: something had a dropTargetSelector but we could not
    // find a match. For now, failing silently
    if (args == null) {
      return result;
    }
    const feedback = {
      input,
      source,
      element: args.element
    };

    // if dropping is not allowed, skip this drop target
    // and continue looking up the DOM tree
    if (args.canDrop && !args.canDrop(feedback)) {
      return getActualDropTargets({
        source,
        target: args.element.parentElement,
        input,
        result
      });
    }
    const data = (_args$getData = (_args$getData2 = args.getData) === null || _args$getData2 === void 0 ? void 0 : _args$getData2.call(args, feedback)) !== null && _args$getData !== void 0 ? _args$getData : {};
    const dropEffect = (_args$getDropEffect = (_args$getDropEffect2 = args.getDropEffect) === null || _args$getDropEffect2 === void 0 ? void 0 : _args$getDropEffect2.call(args, feedback)) !== null && _args$getDropEffect !== void 0 ? _args$getDropEffect : defaultDropEffect;
    const sticky = Boolean((_args$getIsSticky = args.getIsSticky) === null || _args$getIsSticky === void 0 ? void 0 : _args$getIsSticky.call(args, feedback));
    const record = {
      data,
      element: args.element,
      dropEffect,
      sticky
    };
    return getActualDropTargets({
      source,
      target: args.element.parentElement,
      input,
      // Using bubble ordering. Same ordering as `event.getPath()`
      result: [...result, record]
    });
  }
  function notifyCurrent({
    eventName,
    payload
  }) {
    for (const record of payload.location.current.dropTargets) {
      var _entry$eventName;
      const entry = registry.get(record.element);
      const args = {
        ...payload,
        self: record
      };
      entry === null || entry === void 0 ? void 0 : (_entry$eventName = entry[eventName]) === null || _entry$eventName === void 0 ? void 0 : _entry$eventName.call(entry,
      // I cannot seem to get the types right here.
      // TS doesn't seem to like that one event can need `nativeSetDragImage`
      // @ts-expect-error
      args);
    }
  }
  const actions = {
    onGenerateDragPreview: notifyCurrent,
    onDrag: notifyCurrent,
    onDragStart: notifyCurrent,
    onDrop: notifyCurrent,
    onDropTargetChange: ({
      payload
    }) => {
      const isCurrent = new Set(payload.location.current.dropTargets.map(record => record.element));
      const visited = new Set();
      for (const record of payload.location.previous.dropTargets) {
        var _entry$onDropTargetCh;
        visited.add(record.element);
        const entry = registry.get(record.element);
        const isOver = isCurrent.has(record.element);
        const args = {
          ...payload,
          self: record
        };
        entry === null || entry === void 0 ? void 0 : (_entry$onDropTargetCh = entry.onDropTargetChange) === null || _entry$onDropTargetCh === void 0 ? void 0 : _entry$onDropTargetCh.call(entry, args);

        // if we cannot find the drop target in the current array, then it has been left
        if (!isOver) {
          var _entry$onDragLeave;
          entry === null || entry === void 0 ? void 0 : (_entry$onDragLeave = entry.onDragLeave) === null || _entry$onDragLeave === void 0 ? void 0 : _entry$onDragLeave.call(entry, args);
        }
      }
      for (const record of payload.location.current.dropTargets) {
        var _entry$onDropTargetCh2, _entry$onDragEnter;
        // already published an update to this drop target
        if (visited.has(record.element)) {
          continue;
        }
        // at this point we have a new drop target that is being entered into
        const args = {
          ...payload,
          self: record
        };
        const entry = registry.get(record.element);
        entry === null || entry === void 0 ? void 0 : (_entry$onDropTargetCh2 = entry.onDropTargetChange) === null || _entry$onDropTargetCh2 === void 0 ? void 0 : _entry$onDropTargetCh2.call(entry, args);
        entry === null || entry === void 0 ? void 0 : (_entry$onDragEnter = entry.onDragEnter) === null || _entry$onDragEnter === void 0 ? void 0 : _entry$onDragEnter.call(entry, args);
      }
    }
  };
  function dispatchEvent(args) {
    // This line does not work in TS 4.2
    // It does work in TS 4.7
    // @ts-expect-error
    actions[args.eventName](args);
  }
  function getIsOver({
    source,
    target,
    input,
    current
  }) {
    const actual = getActualDropTargets({
      source,
      target,
      input
    });

    // stickiness is only relevant when we have less
    // drop targets than we did before
    if (actual.length >= current.length) {
      return actual;
    }

    // less 'actual' drop targets than before,
    // we need to see if 'stickiness' applies

    // An old drop target will continue to be dropped on if:
    // 1. it has the same parent
    // 2. nothing exists in it's previous index

    const lastCaptureOrdered = copyReverse(current);
    const actualCaptureOrdered = copyReverse(actual);
    const resultCaptureOrdered = [];
    for (let index = 0; index < lastCaptureOrdered.length; index++) {
      const last = lastCaptureOrdered[index];
      const fresh = actualCaptureOrdered[index];

      // if a record is in the new index -> use that
      // it will have the latest data + dropEffect
      if (fresh != null) {
        resultCaptureOrdered.push(fresh);
        continue;
      }

      // At this point we have no drop target in the old spot
      // Check to see if we can use a previous sticky drop target

      // stickiness is based on relationships to a parent
      // so if we hit a drop target that is not sticky we
      // can finish our search
      if (!last.sticky) {
        break;
      }

      // We only want the previous sticky item to 'stick' if
      // the parent of the sticky item is unchanged

      // The "parent" is the one inside of `resultCaptureOrdered`
      // (the parent might be a drop target that was sticky)
      const parent = resultCaptureOrdered[index - 1];
      const lastParent = lastCaptureOrdered[index - 1];

      // parents are the same (might both be undefined for index == 0)
      // we can add the last entry and keep searching
      if ((parent === null || parent === void 0 ? void 0 : parent.element) === (lastParent === null || lastParent === void 0 ? void 0 : lastParent.element)) {
        resultCaptureOrdered.push(last);
        continue;
      }
      // parents are not the same, we can exit our search
      break;
    }

    // return bubble ordered result
    return copyReverse(resultCaptureOrdered);
  }
  return {
    dropTargetForConsumers,
    getIsOver,
    dispatchEvent
  };
}